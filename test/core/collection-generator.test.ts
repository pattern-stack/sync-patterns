/**
 * CollectionGenerator Tests
 *
 * Tests for TanStack DB collection generation from EntityModel.
 * Collections provide normalized storage with relationship support.
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import type { OpenAPIV3 } from 'openapi-types'
import { EntityResolver } from '../../src/core/entity-resolver.js'
import { CollectionGenerator } from '../../src/core/collection-generator.js'
import type { EntityModel } from '../../src/core/entity-model.js'

// Test fixtures
const fixturesDir = resolve(import.meta.dirname, '../fixtures')

function loadFixture(name: string): OpenAPIV3.Document {
  const content = readFileSync(resolve(fixturesDir, name), 'utf-8')
  return JSON.parse(content) as OpenAPIV3.Document
}

function resolveFixture(name: string): EntityModel {
  const spec = loadFixture(name)
  const resolver = new EntityResolver()
  return resolver.resolve(spec)
}

describe('CollectionGenerator', () => {
  let generator: CollectionGenerator

  beforeAll(() => {
    generator = new CollectionGenerator()
  })

  describe('file generation', () => {
    it('generates entity collection files', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)

      expect(output.entities.has('accounts')).toBe(true)
    })

    it('generates store file with all collections', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)

      expect(output.store).toContain('createStore')
      expect(output.store).toContain('accountsCollection')
      expect(output.store).toContain('initializeStore')
      expect(output.store).toContain('getStore')
    })

    it('generates index file with exports', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)

      expect(output.index).toContain('export')
      expect(output.index).toContain('initializeStore')
      expect(output.index).toContain('getStore')
      expect(output.index).toContain('accountsCollection')
    })
  })

  describe('collection definition', () => {
    it('generates collection with createCollection', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)
      const code = output.entities.get('accounts')!

      expect(code).toContain('createCollection')
      expect(code).toContain("name: 'accounts'")
      expect(code).toContain("primaryKey: 'id'")
    })

    it('imports schema from schemas directory', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)
      const code = output.entities.get('accounts')!

      expect(code).toContain("from '../schemas/index.js'")
      expect(code).toContain('AccountSchema')
    })

    it('includes file header with generation warning', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)
      const code = output.entities.get('accounts')!

      expect(code).toContain('DO NOT EDIT')
      expect(code).toContain('Generated by sync-patterns CLI')
    })
  })

  describe('relationship detection', () => {
    it('detects belongsTo relationships from _id fields', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)
      const code = output.entities.get('transactions')!

      // Transactions have category_id and account_id
      expect(code).toContain('belongsTo')
      expect(code).toContain('category')
      expect(code).toContain('account')
    })

    it('detects hasMany relationships from inverse FK', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)
      const code = output.entities.get('categories')!

      // Categories should have hasMany transactions
      expect(code).toContain('hasMany')
      expect(code).toContain('transactions')
    })

    it('imports related collections for belongsTo', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)
      const code = output.entities.get('transactions')!

      expect(code).toContain('categoriesCollection')
      expect(code).toContain('accountsCollection')
    })

    it('uses lazy import for hasMany to avoid circular deps', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)
      const code = output.entities.get('categories')!

      // hasMany should use dynamic import to avoid circular dependencies
      expect(code).toContain('() => import')
    })
  })

  describe('store generation', () => {
    it('generates SyncStore interface with all collections', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)

      expect(output.store).toContain('interface SyncStore')
      expect(output.store).toContain('transactions: typeof transactionsCollection')
      expect(output.store).toContain('categories: typeof categoriesCollection')
      expect(output.store).toContain('accounts: typeof accountsCollection')
    })

    it('generates singleton pattern with initializeStore', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)

      expect(output.store).toContain('let store: SyncStore | null = null')
      expect(output.store).toContain('if (store) return store')
    })

    it('generates getStore with error for uninitialized', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)

      expect(output.store).toContain("throw new Error('Store not initialized")
    })

    it('re-exports all collections from store', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)

      expect(output.store).toContain('export { accountsCollection }')
    })
  })

  describe('JSDoc generation', () => {
    it('includes JSDoc by default', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)
      const code = output.entities.get('accounts')!

      expect(code).toContain('/**')
      expect(code).toContain('*/\nexport const accountsCollection')
    })

    it('can disable JSDoc with option', () => {
      const generatorNoJSDoc = new CollectionGenerator({ includeJSDoc: false })
      const model = resolveFixture('minimal-crud.json')
      const output = generatorNoJSDoc.generate(model)
      const code = output.entities.get('accounts')!

      // Should not have JSDoc block before collection definition
      expect(code).not.toMatch(/\/\*\*[\s\S]*?\*\/\s*export const accountsCollection/)
    })
  })

  describe('type exports', () => {
    it('exports entity type from collection file', () => {
      const model = resolveFixture('minimal-crud.json')
      const output = generator.generate(model)
      const code = output.entities.get('accounts')!

      expect(code).toContain('export type { Account }')
    })
  })

  describe('multiple entities', () => {
    it('generates files for all entities', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)

      expect(output.entities.has('transactions')).toBe(true)
      expect(output.entities.has('categories')).toBe(true)
      expect(output.entities.has('accounts')).toBe(true)
    })

    it('store includes all collections in createStore call', () => {
      const model = resolveFixture('with-entity-references.json')
      const output = generator.generate(model)

      expect(output.store).toContain('transactions: transactionsCollection')
      expect(output.store).toContain('categories: categoriesCollection')
      expect(output.store).toContain('accounts: accountsCollection')
    })
  })
})
