/**
 * Collection Generator
 *
 * Generates TanStack DB collection definitions from EntityModel.
 * Collections provide normalized storage with relationship support.
 *
 * Output structure:
 *   collections/
 *     orders.ts        - ordersCollection with relationships
 *     customers.ts     - customersCollection
 *     store.ts         - createStore() with all collections
 *     index.ts         - Re-exports all
 *
 * @see SYNC-014 specification for architecture details
 */

import type {
  EntityModel,
  EntityDefinition,
} from './entity-model.js'
import { buildRelationshipMap, type Relationship } from './relationship-detector.js'

// Re-export Relationship type for consumers
export type { Relationship } from './relationship-detector.js'

// =============================================================================
// Types
// =============================================================================

export interface GeneratedCollections {
  /** Collection files keyed by entity name */
  entities: Map<string, string>
  /** Store initialization file */
  store: string
  /** Index file with exports */
  index: string
}

export interface CollectionGeneratorOptions {
  /** Include JSDoc comments (default: true) */
  includeJSDoc?: boolean
}

const DEFAULT_OPTIONS: Required<CollectionGeneratorOptions> = {
  includeJSDoc: true,
}

// =============================================================================
// Collection Generator
// =============================================================================

export class CollectionGenerator {
  private options: Required<CollectionGeneratorOptions>

  constructor(options: CollectionGeneratorOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options }
  }

  generate(model: EntityModel): GeneratedCollections {
    const entities = new Map<string, string>()

    // Detect relationships for all entities using shared utility
    const relationshipMap = buildRelationshipMap(model.entities)

    // Generate collection files
    for (const [name, entity] of model.entities) {
      const relationships = relationshipMap.get(name) || []
      const code = this.generateEntityCollection(entity, relationships, relationshipMap)
      entities.set(name, code)
    }

    return {
      entities,
      store: this.generateStore(model, relationshipMap),
      index: this.generateIndex(model),
    }
  }

  // ===========================================================================
  // Collection File Generation
  // ===========================================================================

  private generateEntityCollection(
    entity: EntityDefinition,
    relationships: Relationship[],
    _allRelationships: Map<string, Relationship[]>
  ): string {
    const lines: string[] = []
    const { pascalName } = entity

    // File header
    lines.push(this.generateFileHeader(pascalName))
    lines.push('')

    // Imports
    lines.push(this.generateImports(entity, relationships))
    lines.push('')

    // Collection definition
    lines.push(this.generateCollectionDefinition(entity, relationships))
    lines.push('')

    // Type exports
    lines.push(`// Type exports for external use`)
    lines.push(`export type { ${pascalName} }`)
    lines.push('')

    return lines.join('\n')
  }

  private generateFileHeader(entityName: string): string {
    return `/**
 * TanStack DB collection for ${entityName} entity.
 *
 * DO NOT EDIT - Generated by sync-patterns CLI.
 */`
  }

  private generateImports(
    entity: EntityDefinition,
    relationships: Relationship[]
  ): string {
    const imports: string[] = []

    // TanStack DB imports based on relationship types
    const dbImports: string[] = ['createCollection']
    const hasBelongsTo = relationships.some((r) => r.type === 'belongsTo')
    const hasHasMany = relationships.some((r) => r.type === 'hasMany')

    if (hasBelongsTo) dbImports.push('belongsTo')
    if (hasHasMany) dbImports.push('hasMany')

    imports.push(`import { ${dbImports.join(', ')} } from '@tanstack/db'`)

    // Schema imports
    const schemaName = entity.schemas.item || entity.pascalName
    imports.push(
      `import { ${schemaName}Schema, type ${schemaName} } from '../schemas/index.js'`
    )

    // Related collection imports (only for belongsTo - avoid circular imports)
    const belongsToRelations = relationships.filter((r) => r.type === 'belongsTo')
    for (const rel of belongsToRelations) {
      imports.push(
        `import { ${rel.targetEntity}Collection } from './${this.toKebabCase(rel.targetEntity)}.js'`
      )
    }

    return imports.join('\n')
  }

  private generateCollectionDefinition(
    entity: EntityDefinition,
    relationships: Relationship[]
  ): string {
    const { pascalName, name } = entity
    const schemaName = entity.schemas.item || pascalName

    const jsdoc = this.options.includeJSDoc
      ? `/**
 * ${pascalName} collection
 *
 * Provides normalized storage with relationship support.
 * Use useLiveQuery() to subscribe to reactive updates.
 */
`
      : ''

    // Build relationships object
    let relationshipsBlock = ''
    if (relationships.length > 0) {
      const relationLines: string[] = []

      for (const rel of relationships) {
        if (rel.type === 'belongsTo') {
          relationLines.push(`    ${rel.name}: belongsTo(${rel.targetEntity}Collection, {
      foreignKey: '${rel.foreignKey}',
    })`)
        } else {
          // hasMany - need lazy import to avoid circular dependencies
          relationLines.push(`    ${rel.name}: hasMany(() => import('./${this.toKebabCase(rel.targetEntity)}.js').then(m => m.${rel.targetEntity}Collection), {
      foreignKey: '${rel.foreignKey}',
    })`)
        }
      }

      relationshipsBlock = `

  relationships: {
${relationLines.join(',\n')}
  },`
    }

    return `${jsdoc}export const ${name}Collection = createCollection<${schemaName}>({
  name: '${name}',
  schema: ${schemaName}Schema,
  primaryKey: 'id',${relationshipsBlock}
})`
  }

  // ===========================================================================
  // Store Generation
  // ===========================================================================

  private generateStore(
    model: EntityModel,
    _relationshipMap: Map<string, Relationship[]>
  ): string {
    const lines: string[] = []
    const entityNames = [...model.entities.keys()]

    // Header
    lines.push(`/**
 * TanStack DB store initialization.
 *
 * DO NOT EDIT - Generated by sync-patterns CLI.
 */`)
    lines.push('')

    // Imports
    lines.push(`import { createStore, type Store } from '@tanstack/db'`)

    // Import all collections
    for (const name of entityNames) {
      lines.push(
        `import { ${name}Collection } from './${this.toKebabCase(name)}.js'`
      )
    }
    lines.push('')

    // Store interface
    const interfaceProps = entityNames
      .map((name) => `  ${name}: typeof ${name}Collection`)
      .join('\n')

    lines.push(`export interface SyncStore extends Store {
${interfaceProps}
}`)
    lines.push('')

    // Store singleton
    lines.push(`let store: SyncStore | null = null`)
    lines.push('')

    // Initialize function
    const collectionsObj = entityNames
      .map((name) => `      ${name}: ${name}Collection`)
      .join(',\n')

    lines.push(`/**
 * Initialize the TanStack DB store.
 *
 * Call this once at app startup before using any collections.
 * Currently in-memory only; PGlite persistence added in Phase 2.
 */
export function initializeStore(): SyncStore {
  if (store) return store

  store = createStore({
    collections: {
${collectionsObj}
    },
  }) as SyncStore

  return store
}`)
    lines.push('')

    // Get function
    lines.push(`/**
 * Get the initialized store.
 *
 * @throws Error if store not initialized
 */
export function getStore(): SyncStore {
  if (!store) {
    throw new Error('Store not initialized. Call initializeStore() first.')
  }
  return store
}`)
    lines.push('')

    // Re-exports
    const reexports = entityNames
      .map((name) => `${name}Collection`)
      .join(', ')

    lines.push(`// Re-export collections for direct access`)
    lines.push(`export { ${reexports} }`)
    lines.push('')

    return lines.join('\n')
  }

  // ===========================================================================
  // Index Generation
  // ===========================================================================

  private generateIndex(model: EntityModel): string {
    const lines: string[] = []
    const entityNames = [...model.entities.keys()]

    lines.push(`/**
 * TanStack DB Collections
 *
 * DO NOT EDIT - Generated by sync-patterns CLI.
 */`)
    lines.push('')

    // Re-export store
    lines.push(`export { initializeStore, getStore, type SyncStore } from './store.js'`)
    lines.push('')

    // Re-export all collections
    for (const name of entityNames) {
      const entity = model.entities.get(name)!
      lines.push(
        `export { ${name}Collection, type ${entity.pascalName} } from './${this.toKebabCase(name)}.js'`
      )
    }
    lines.push('')

    return lines.join('\n')
  }

  // ===========================================================================
  // Helpers
  // ===========================================================================

  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[\s_]+/g, '-')
      .toLowerCase()
  }
}
