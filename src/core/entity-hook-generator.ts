/**
 * Entity Hook Generator
 *
 * Generates unified entity hooks that combine:
 * - TanStack Query for network fetching
 * - TanStack DB collections for normalized storage
 * - Live queries for reactive updates
 * - Optimistic mutations with rollback
 * - Broadcast integration for cross-client sync
 *
 * Output structure:
 *   entities/
 *     orders.ts     - useOrders, useOrder, useCreateOrder, etc.
 *     customers.ts
 *     index.ts      - Re-exports all
 *
 * @see SYNC-014 specification for architecture details
 */

import type { EntityModel, EntityDefinition } from './entity-model.js'
import { buildRelationshipMap, type Relationship } from './relationship-detector.js'

// =============================================================================
// Types
// =============================================================================

export interface GeneratedEntityHooks {
  /** Entity hook files keyed by entity name */
  entities: Map<string, string>
  /** Index file with exports */
  index: string
}

export interface EntityHookGeneratorOptions {
  /** Include JSDoc comments (default: true) */
  includeJSDoc?: boolean
  /** Enable optimistic mutations (default: true) */
  optimisticMutations?: boolean
  /** Enable broadcast integration (default: true) */
  broadcastIntegration?: boolean
  /** Query stale time in milliseconds (default: 60000 = 1 minute) */
  staleTime?: number
  /**
   * Import path for runtime utilities (useBroadcastInvalidation).
   * Default: '@pattern-stack/sync-patterns/runtime'
   */
  runtimeImportPath?: string
}

const DEFAULT_OPTIONS: Required<EntityHookGeneratorOptions> = {
  includeJSDoc: true,
  optimisticMutations: true,
  broadcastIntegration: true,
  staleTime: 60000,
  runtimeImportPath: '@pattern-stack/sync-patterns/runtime',
}

// =============================================================================
// Entity Hook Generator
// =============================================================================

export class EntityHookGenerator {
  private options: Required<EntityHookGeneratorOptions>
  private allEntities: Map<string, EntityDefinition> = new Map()

  constructor(options: EntityHookGeneratorOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options }
  }

  generate(model: EntityModel): GeneratedEntityHooks {
    this.allEntities = model.entities
    const entities = new Map<string, string>()

    // Detect relationships for all entities using shared utility
    const relationshipMap = buildRelationshipMap(model.entities)

    // Generate entity hook files
    for (const [name, entity] of model.entities) {
      const relationships = relationshipMap.get(name) || []
      const code = this.generateEntityHooks(entity, relationships)
      entities.set(name, code)
    }

    return {
      entities,
      index: this.generateIndex(model),
    }
  }

  // ===========================================================================
  // Entity Hooks Generation
  // ===========================================================================

  private generateEntityHooks(
    entity: EntityDefinition,
    relationships: Relationship[]
  ): string {
    const lines: string[] = []
    const { pascalName } = entity

    // File header
    lines.push(this.generateFileHeader(pascalName))
    lines.push('')

    // Imports
    lines.push(this.generateImports(entity, relationships))
    lines.push('')

    // Query Keys
    lines.push(this.generateQueryKeys(entity))
    lines.push('')

    // Types
    lines.push(this.generateTypes(entity, relationships))
    lines.push('')

    // Internal sync hooks
    lines.push(this.generateSyncHooks(entity))
    lines.push('')

    // Public list hook
    lines.push(this.generateListHook(entity, relationships))
    lines.push('')

    // Public single item hook
    lines.push(this.generateDetailHook(entity, relationships))
    lines.push('')

    // Mutation hooks
    if (entity.operations.create) {
      lines.push(this.generateCreateHook(entity))
      lines.push('')
    }
    if (entity.operations.update) {
      lines.push(this.generateUpdateHook(entity))
      lines.push('')
    }
    if (entity.operations.delete) {
      lines.push(this.generateDeleteHook(entity))
      lines.push('')
    }

    return lines.join('\n')
  }

  private generateFileHeader(entityName: string): string {
    return `/**
 * Unified hooks for ${entityName} entity.
 *
 * Uses TanStack DB for normalized storage and live queries.
 * TanStack Query handles network fetching internally.
 *
 * DO NOT EDIT - Generated by sync-patterns CLI.
 */`
  }

  private generateImports(
    entity: EntityDefinition,
    _relationships: Relationship[]
  ): string {
    const imports: string[] = []
    const { pascalName } = entity

    // React imports
    imports.push(`import { useEffect, useMemo } from 'react'`)

    // TanStack Query imports
    imports.push(
      `import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query'`
    )

    // TanStack DB imports
    imports.push(`import { useLiveQuery } from '@tanstack/db-react'`)

    // Collection import
    imports.push(
      `import { ${entity.name}Collection } from '../collections/${this.toKebabCase(entity.name)}.js'`
    )

    // API import
    imports.push(`import { ${entity.name}Api } from '../api/${this.toKebabCase(entity.name)}.js'`)

    // Broadcast import (if enabled)
    if (this.options.broadcastIntegration) {
      imports.push(
        `import { useBroadcastInvalidation } from '${this.options.runtimeImportPath}'`
      )
    }

    // Schema type imports
    const types: string[] = [pascalName]
    if (entity.schemas.createRequest) types.push(entity.schemas.createRequest)
    if (entity.schemas.updateRequest) types.push(entity.schemas.updateRequest)

    imports.push(
      `import type { ${types.join(', ')} } from '../schemas/index.js'`
    )

    return imports.join('\n')
  }

  private generateQueryKeys(entity: EntityDefinition): string {
    const { singular, name } = entity

    return `// ============================================================================
// Query Keys
// ============================================================================

export const ${singular}Keys = {
  all: ['${name}'] as const,
  lists: () => [...${singular}Keys.all, 'list'] as const,
  list: (filters?: ${entity.pascalName}Filters) => [...${singular}Keys.lists(), filters] as const,
  details: () => [...${singular}Keys.all, 'detail'] as const,
  detail: (id: string) => [...${singular}Keys.details(), id] as const,
}`
  }

  private generateTypes(
    entity: EntityDefinition,
    relationships: Relationship[]
  ): string {
    const { pascalName, name } = entity
    const pascalPlural = this.toPascalCasePlural(name)
    const lines: string[] = []

    lines.push(`// ============================================================================
// Types
// ============================================================================`)
    lines.push('')

    // Filters type
    lines.push(`export interface ${pascalName}Filters {
  [key: string]: unknown
}`)
    lines.push('')

    // Relations type and WithRelations conditional type (for include option)
    if (relationships.length > 0) {
      const relationNames = relationships.map((r) => `'${r.name}'`).join(' | ')
      lines.push(`export type ${pascalName}Relation = ${relationNames}`)
      lines.push('')

      // Generate relations map type
      const relationMapEntries = relationships.map((r) => {
        const targetPascal = this.toPascalCasePlural(r.targetEntity).slice(0, -1) // Singular PascalCase
        if (r.type === 'hasMany') {
          return `  ${r.name}: ${targetPascal}[]`
        }
        return `  ${r.name}: ${targetPascal}`
      })

      lines.push(`/**
 * Relation types for ${pascalName}.
 * Used by WithRelations to conditionally add relation fields to return type.
 */
export interface ${pascalName}Relations {
${relationMapEntries.join('\n')}
}`)
      lines.push('')

      // Generate WithRelations conditional type
      lines.push(`/**
 * Conditionally add relation fields based on include parameter.
 *
 * @example
 * \`\`\`ts
 * // Without include - no relation fields
 * const { data } = use${pascalName}(id)
 * data.${relationships[0].name} // ❌ TypeScript error
 *
 * // With include - relation fields available
 * const { data } = use${pascalName}(id, { include: ['${relationships[0].name}'] })
 * data.${relationships[0].name} // ✅ Works
 * \`\`\`
 */
export type ${pascalName}WithRelations<I extends readonly ${pascalName}Relation[] = []> =
  ${pascalName} & Pick<${pascalName}Relations, I[number]>`)
      lines.push('')
    }

    // UseEntities options (uses plural form)
    const includeType = relationships.length > 0 ? `${pascalName}Relation` : 'never'
    lines.push(`export interface Use${pascalPlural}Options<I extends readonly ${includeType}[] = []> {
  /** Filter criteria */
  where?: ${pascalName}Filters
  /** Related entities to include - narrows return type */
  include?: I
  /** Sort configuration */
  orderBy?: Partial<Record<keyof ${pascalName}, 'asc' | 'desc'>>
  /** Enable broadcast auto-refresh (default: true) */
  autoRefresh?: boolean
}`)
    lines.push('')

    // UseEntity options (uses singular form)
    lines.push(`export interface Use${pascalName}Options<I extends readonly ${includeType}[] = []> {
  /** Related entities to include - narrows return type */
  include?: I
  /** Enable broadcast auto-refresh (default: true) */
  autoRefresh?: boolean
}`)

    return lines.join('\n')
  }

  private generateSyncHooks(entity: EntityDefinition): string {
    const { pascalName, singular, name } = entity
    const pascalPlural = this.toPascalCasePlural(name)
    const staleTime = this.options.staleTime

    return `// ============================================================================
// Internal: Sync Hooks (populate collection from API)
// ============================================================================

function use${pascalPlural}Sync(filters?: ${pascalName}Filters) {
  const query = useQuery({
    queryKey: ${singular}Keys.list(filters),
    queryFn: () => ${name}Api.list(),
    staleTime: ${staleTime},
  })

  // Sync API response into collection
  useEffect(() => {
    if (query.data) {
      // Handle both array and paginated responses
      const items = Array.isArray(query.data) ? query.data : (query.data as { items?: ${pascalName}[] }).items || []
      ${name}Collection.upsertMany(items)
    }
  }, [query.data])

  return query
}

function use${pascalName}Sync(id: string) {
  const query = useQuery({
    queryKey: ${singular}Keys.detail(id),
    queryFn: () => ${name}Api.get(id),
    enabled: !!id,
  })

  useEffect(() => {
    if (query.data) {
      ${name}Collection.upsert(query.data)
    }
  }, [query.data])

  return query
}`
  }

  private generateListHook(
    entity: EntityDefinition,
    _relationships: Relationship[]
  ): string {
    const { pascalName, singular, name } = entity
    const pascalPlural = this.toPascalCasePlural(name)
    const jsdoc = this.options.includeJSDoc

    const jsdocBlock = jsdoc
      ? `/**
 * Fetch and subscribe to ${name}.
 *
 * Returns live query that updates when:
 * - Initial fetch completes
 * - Any ${singular} is created/updated/deleted locally
 * - Broadcast triggers refetch from other clients
 *
 * @example
 * \`\`\`tsx
 * const { data: ${name}, isLoading } = use${pascalPlural}({
 *   where: { status: 'active' },
 * })
 * \`\`\`
 */
`
      : ''

    const broadcastBlock = this.options.broadcastIntegration
      ? `
  // Subscribe to broadcast for cross-client updates
  useBroadcastInvalidation({
    channel: '${singular}',
    queryKeyPrefix: ${singular}Keys.lists(),
    enabled: autoRefresh,
  })`
      : ''

    return `// ============================================================================
// Public: List Hook
// ============================================================================

${jsdocBlock}export function use${pascalPlural}(options: Use${pascalPlural}Options = {}) {
  const { where, include, orderBy, autoRefresh = true } = options

  // Sync from API to collection
  const sync = use${pascalPlural}Sync(where)
${broadcastBlock}

  // Build live query
  const liveQuery = useMemo(() => {
    let query = ${name}Collection.query()

    if (where) {
      Object.entries(where).forEach(([key, value]) => {
        if (value !== undefined) {
          query = query.where(key as keyof ${pascalName}, '=', value)
        }
      })
    }

    if (orderBy) {
      Object.entries(orderBy).forEach(([key, direction]) => {
        query = query.orderBy(key, direction as 'asc' | 'desc')
      })
    }

    if (include?.length) {
      include.forEach(relation => {
        query = query.include(relation)
      })
    }

    return query
  }, [where, orderBy, include])

  // Subscribe to collection
  const data = useLiveQuery(liveQuery)

  return {
    data: data ?? [],
    isLoading: sync.isLoading,
    error: sync.error,
    refetch: sync.refetch,
  }
}`
  }

  private generateDetailHook(
    entity: EntityDefinition,
    _relationships: Relationship[]
  ): string {
    const { pascalName, singular, name } = entity
    const jsdoc = this.options.includeJSDoc

    const jsdocBlock = jsdoc
      ? `/**
 * Fetch and subscribe to a single ${singular}.
 *
 * @example
 * \`\`\`tsx
 * const { data: ${singular}, isLoading } = use${pascalName}(${singular}Id)
 * \`\`\`
 */
`
      : ''

    const broadcastBlock = this.options.broadcastIntegration
      ? `
  // Subscribe to broadcast
  useBroadcastInvalidation({
    channel: '${singular}',
    queryKeyPrefix: ${singular}Keys.detail(id),
    enabled: autoRefresh,
  })`
      : ''

    return `// ============================================================================
// Public: Single Item Hook
// ============================================================================

${jsdocBlock}export function use${pascalName}(id: string, options: Use${pascalName}Options = {}) {
  const { include, autoRefresh = true } = options

  // Sync from API to collection
  const sync = use${pascalName}Sync(id)
${broadcastBlock}

  // Build live query for single item
  const liveQuery = useMemo(() => {
    let query = ${name}Collection.query().where('id', '=', id)

    if (include?.length) {
      include.forEach(relation => {
        query = query.include(relation)
      })
    }

    return query.first()
  }, [id, include])

  const data = useLiveQuery(liveQuery)

  return {
    data,
    isLoading: sync.isLoading,
    error: sync.error,
    refetch: sync.refetch,
  }
}`
  }

  private generateCreateHook(entity: EntityDefinition): string {
    const { pascalName, singular, name } = entity
    const createType = entity.schemas.createRequest || `${pascalName}Create`
    const jsdoc = this.options.includeJSDoc

    const jsdocBlock = jsdoc
      ? `/**
 * Create a new ${singular} with optimistic update.
 *
 * UI updates instantly. API confirms in background.
 * Rollback on error.
 *
 * @example
 * \`\`\`tsx
 * const create${pascalName} = useCreate${pascalName}()
 *
 * create${pascalName}.mutate(data, {
 *   onSuccess: (${singular}) => navigate(\`/${name}/\${${singular}.id}\`),
 *   onError: () => toast.error('Failed to create ${singular}'),
 * })
 * \`\`\`
 */
`
      : ''

    const optimisticBlock = this.options.optimisticMutations
      ? `
    onMutate: async (newData: ${createType}) => {
      // Cancel in-flight fetches
      await queryClient.cancelQueries({ queryKey: ${singular}Keys.lists() })

      // Generate temp ID for optimistic insert
      const tempId = \`temp-\${crypto.randomUUID()}\`
      const optimistic${pascalName}: ${pascalName} = {
        ...newData,
        id: tempId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      } as ${pascalName}

      // Insert into collection (all live queries update instantly)
      ${name}Collection.insert(optimistic${pascalName})

      return { tempId }
    },

    onSuccess: (server${pascalName}: ${pascalName}, _variables: ${createType}, context: { tempId: string } | undefined) => {
      // Replace temp with real ${singular} from server
      if (context?.tempId) {
        ${name}Collection.delete(context.tempId)
      }
      ${name}Collection.upsert(server${pascalName})
    },

    onError: (_error: Error, _variables: ${createType}, context: { tempId: string } | undefined) => {
      // Rollback optimistic insert
      if (context?.tempId) {
        ${name}Collection.delete(context.tempId)
      }
    },
`
      : ''

    return `// ============================================================================
// Public: Create Mutation
// ============================================================================

${jsdocBlock}export function useCreate${pascalName}() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: ${createType}) => ${name}Api.create(data),
${optimisticBlock}
    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ${singular}Keys.lists() })
    },
  })
}`
  }

  private generateUpdateHook(entity: EntityDefinition): string {
    const { pascalName, singular, name } = entity
    const updateType = entity.schemas.updateRequest || `${pascalName}Update`
    const jsdoc = this.options.includeJSDoc

    const jsdocBlock = jsdoc
      ? `/**
 * Update an existing ${singular} with optimistic update.
 */
`
      : ''

    // Define the mutation variables type for reuse
    const mutationVarsType = `{ id: string; data: ${updateType} }`
    const contextType = `{ previous: ${pascalName} | undefined }`

    const optimisticBlock = this.options.optimisticMutations
      ? `
    onMutate: async ({ id, data }: ${mutationVarsType}) => {
      await queryClient.cancelQueries({ queryKey: ${singular}Keys.detail(id) })

      // Snapshot for rollback
      const previous = ${name}Collection.findById(id)

      // Optimistic update
      if (previous) {
        ${name}Collection.update(id, {
          ...data,
          updated_at: new Date().toISOString(),
        })
      }

      return { previous }
    },

    onSuccess: (server${pascalName}: ${pascalName}) => {
      // Merge server response
      ${name}Collection.upsert(server${pascalName})
    },

    onError: (_error: Error, { id }: ${mutationVarsType}, context: ${contextType} | undefined) => {
      // Rollback
      if (context?.previous) {
        ${name}Collection.upsert(context.previous)
      }
    },
`
      : ''

    return `// ============================================================================
// Public: Update Mutation
// ============================================================================

${jsdocBlock}export function useUpdate${pascalName}() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: ${updateType} }) =>
      ${name}Api.update(id, data),
${optimisticBlock}
    onSettled: (_data: ${pascalName} | undefined, _error: Error | null, { id }: { id: string; data: ${updateType} }) => {
      queryClient.invalidateQueries({ queryKey: ${singular}Keys.detail(id) })
    },
  })
}`
  }

  private generateDeleteHook(entity: EntityDefinition): string {
    const { pascalName, singular, name } = entity
    const jsdoc = this.options.includeJSDoc

    const jsdocBlock = jsdoc
      ? `/**
 * Delete a ${singular} with optimistic update.
 */
`
      : ''

    const deleteContextType = `{ previous: ${pascalName} | undefined }`

    const optimisticBlock = this.options.optimisticMutations
      ? `
    onMutate: async (id: string) => {
      await queryClient.cancelQueries({ queryKey: ${singular}Keys.all })

      // Snapshot for rollback
      const previous = ${name}Collection.findById(id)

      // Optimistic delete
      ${name}Collection.delete(id)

      return { previous }
    },

    onError: (_error: Error, _id: string, context: ${deleteContextType} | undefined) => {
      // Rollback
      if (context?.previous) {
        ${name}Collection.insert(context.previous)
      }
    },
`
      : ''

    return `// ============================================================================
// Public: Delete Mutation
// ============================================================================

${jsdocBlock}export function useDelete${pascalName}() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id: string) => ${name}Api.delete(id),
${optimisticBlock}
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ${singular}Keys.lists() })
    },
  })
}`
  }

  // ===========================================================================
  // Index Generation
  // ===========================================================================

  private generateIndex(model: EntityModel): string {
    const lines: string[] = []
    const entityNames = [...model.entities.keys()]

    lines.push(`/**
 * Unified Entity Hooks
 *
 * DO NOT EDIT - Generated by sync-patterns CLI.
 */`)
    lines.push('')

    // Export all entity hooks
    for (const name of entityNames) {
      const entity = model.entities.get(name)!
      const { pascalName, singular } = entity
      const pascalPlural = this.toPascalCasePlural(name)
      const kebab = this.toKebabCase(name)

      const exports: string[] = [
        // Query keys
        `${singular}Keys`,
        // List hook
        `use${pascalPlural}`,
        // Detail hook
        `use${pascalName}`,
        // Types
        `type ${pascalName}Filters`,
        `type Use${pascalPlural}Options`,
        `type Use${pascalName}Options`,
      ]

      // Mutation hooks
      if (entity.operations.create) exports.push(`useCreate${pascalName}`)
      if (entity.operations.update) exports.push(`useUpdate${pascalName}`)
      if (entity.operations.delete) exports.push(`useDelete${pascalName}`)

      lines.push(`export {`)
      for (const exp of exports) {
        lines.push(`  ${exp},`)
      }
      lines.push(`} from './${kebab}.js'`)
      lines.push('')
    }

    return lines.join('\n')
  }

  // ===========================================================================
  // Helpers
  // ===========================================================================

  /**
   * Convert entity name to PascalCase plural.
   * E.g., "categories" -> "Categories", "accounts" -> "Accounts"
   */
  private toPascalCasePlural(name: string): string {
    return name.charAt(0).toUpperCase() + name.slice(1)
  }

  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[\s_]+/g, '-')
      .toLowerCase()
  }
}
